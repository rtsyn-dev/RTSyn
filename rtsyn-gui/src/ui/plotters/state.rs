//! Plotter UI components and window management for RTSyn GUI.
//!
//! This module provides the user interface components for managing and displaying
//! real-time plotting windows in the RTSyn application. It handles:
//!
//! - Plotter window rendering and viewport management
//! - Interactive controls for plot customization (knobs, wheels, timebase)
//! - Series data visualization with scaling and offset controls
//! - Export functionality for plot images (PNG/SVG)
//! - Settings dialogs for plot appearance and behavior
//! - Connection management for plotter plugins
//! - Notification display for plotter-specific messages
//!
//! The module implements a comprehensive plotting interface that allows users to
//! visualize real-time data streams from various plugins, customize appearance,
//! and export plots for documentation or analysis purposes.

use super::*;
use crate::state::PlotterPreviewState;

impl GuiApp {
/// Determines if a series name is a placeholder generated by the system.
    ///
    /// This function identifies automatically generated series names that follow the
    /// pattern "Series N" where N is a number. This distinction is important for
    /// deciding whether to replace placeholder names with more meaningful names
    /// derived from actual data connections.
    ///
    /// # Parameters
    /// - `name`: The series name string to check
    ///
    /// # Returns
    /// `true` if the name matches the placeholder pattern "Series N", `false` otherwise
    ///
    /// # Pattern Recognition
    /// - Trims whitespace from the input name
    /// - Checks for exact "Series " prefix
    /// - Validates that the suffix is a parseable positive integer
    /// - Case-sensitive matching (requires exact capitalization)
    ///
    /// # Use Cases
    /// - Determining when to auto-update series names from connection metadata
    /// - Preserving user-customized series names while updating defaults
    /// - Managing the transition from placeholder to meaningful names
    ///
    /// # Examples
    /// - `"Series 1"` → `true`
    /// - `"Series 42"` → `true`
    /// - `"Custom Name"` → `false`
    /// - `"series 1"` → `false` (case mismatch)
    /// - `"Series ABC"` → `false` (non-numeric suffix)
    pub(super) fn is_placeholder_series_name(name: &str) -> bool {
        let trimmed = name.trim();
        if !trimmed.starts_with("Series ") {
            return false;
        }
        trimmed["Series ".len()..].parse::<usize>().is_ok()
    }

    /// Synchronizes series control arrays with a seed state, preserving user customizations.
    ///
    /// This function ensures that the series control arrays (names, scales, offsets, colors)
    /// in the target state match the length and structure of a seed state, while intelligently
    /// preserving user customizations and replacing only placeholder values with meaningful
    /// data from the seed.
    ///
    /// # Parameters
    /// - `state`: Mutable reference to the state being synchronized
    /// - `seed`: Reference to the seed state providing the target structure and default values
    ///
    /// # Synchronization Logic
    /// 1. **Size Matching**: Adjusts array lengths to match the seed state
    /// 2. **Expansion**: Adds new entries with seed values when target is smaller
    /// 3. **Truncation**: Removes excess entries when target is larger
    /// 4. **Smart Name Updates**: Replaces placeholder names with seed names while preserving custom names
    ///
    /// # Preservation Rules
    /// - User-defined custom series names are never overwritten
    /// - Placeholder names (e.g., "Series 1") are replaced with meaningful seed names
    /// - Empty names are always replaced with seed names when available
    /// - Scale, offset, and color values are preserved for existing series
    ///
    /// # Use Cases
    /// - Updating plotter settings when connection topology changes
    /// - Maintaining user customizations across plugin reconfigurations
    /// - Initializing new series with sensible defaults
    /// - Handling dynamic changes in the number of data series
    ///
    /// # Implementation Details
    /// - Uses `is_placeholder_series_name()` to identify replaceable names
    /// - Maintains array consistency across all series-related vectors
    /// - Handles edge cases like empty seed states gracefully
    pub(super) fn sync_series_controls_from_seed(state: &mut PlotterPreviewState, seed: &PlotterPreviewState) {
        let target = seed.series_names.len();
        if state.series_names.len() < target {
            for idx in state.series_names.len()..target {
                state.series_names.push(
                    seed.series_names
                        .get(idx)
                        .cloned()
                        .unwrap_or_else(|| format!("Series {}", idx + 1)),
                );
                state.series_scales.push(1.0);
                state.series_offsets.push(0.0);
                state.colors.push(
                    seed.colors
                        .get(idx)
                        .copied()
                        .unwrap_or(egui::Color32::from_rgb(86, 156, 214)),
                );
            }
        } else {
            state.series_names.truncate(target);
            state.series_scales.truncate(target);
            state.series_offsets.truncate(target);
            state.colors.truncate(target);
        }
        // Keep user-defined custom labels, but replace placeholder fallback labels
        // with concrete seed names once real connections/series metadata is available.
        for idx in 0..target {
            if let (Some(current), Some(seed_name)) =
                (state.series_names.get_mut(idx), seed.series_names.get(idx))
            {
                if (current.is_empty() || Self::is_placeholder_series_name(current))
                    && !seed_name.is_empty()
                {
                    *current = seed_name.clone();
                }
            }
        }
    }

    /// Generates meaningful series names based on plugin connections.
    ///
    /// This function creates descriptive names for data series by examining the
    /// connection topology and generating names that reflect the actual data sources.
    /// It provides much more informative labels than generic placeholder names.
    ///
    /// # Parameters
    /// - `plugin_id`: The ID of the plugin for which to generate series names
    /// - `count`: The number of series names to generate
    ///
    /// # Returns
    /// A `Vec<String>` containing generated series names, one for each requested series
    ///
    /// # Name Generation Logic
    /// For each series index `i`:
    /// 1. Constructs the expected input port name as `"in_{i}"`
    /// 2. Searches workspace connections for a connection to this port
    /// 3. If found, creates name as `"{source_plugin}:{source_port}"`
    /// 4. If not found, falls back to placeholder `"Series {i+1}"`
    ///
    /// # Examples
    /// - Connected input: `"SignalGen:output"` (meaningful)
    /// - Unconnected input: `"Series 2"` (placeholder)
    ///
    /// # Use Cases
    /// - Providing context-aware series labels in plot legends
    /// - Helping users identify data sources in multi-series plots
    /// - Automatically updating labels when connections change
    /// - Improving plot readability and documentation value
    ///
    /// # Implementation Details
    /// - Uses workspace connection metadata for name resolution
    /// - Handles missing connections gracefully with fallback names
    /// - Maintains consistent indexing (1-based for user display)
    /// - Leverages `plugin_display_name()` for readable plugin names
    pub(super) fn aligned_series_names(&self, plugin_id: u64, count: usize) -> Vec<String> {
        (0..count)
            .map(|i| {
                let port = format!("in_{i}");
                self.workspace_manager
                    .workspace
                    .connections
                    .iter()
                    .find(|c| c.to_plugin == plugin_id && c.to_port == port)
                    .map(|c| {
                        format!(
                            "{}:{}",
                            self.plugin_display_name(c.from_plugin),
                            c.from_port
                        )
                    })
                    .unwrap_or_else(|| format!("Series {}", i + 1))
            })
            .collect()
    }

    /// Constructs a complete plotter preview state from current plugin configuration.
    ///
    /// This function builds a comprehensive state object that contains all the settings
    /// and metadata needed to render and configure a plotter. It intelligently merges
    /// saved settings with live plugin data and connection information.
    ///
    /// # Parameters
    /// - `plugin_id`: The ID of the plugin to build preview state for
    ///
    /// # Returns
    /// A `PlotterPreviewState` containing all plotter configuration and display settings
    ///
    /// # State Construction Process
    /// 1. **Initialize**: Creates default state with target plugin ID
    /// 2. **Live Data**: Extracts current series count and connection names
    /// 3. **Saved Settings**: Loads previously saved plotter configuration if available
    /// 4. **Series Sync**: Synchronizes series arrays with current connection topology
    /// 5. **Plugin Config**: Incorporates plugin-specific settings (priority, refresh rate)
    /// 6. **Defaults**: Applies sensible defaults for missing configuration
    ///
    /// # Data Sources
    /// - **Plotter Manager**: Saved preview settings and live plotter state
    /// - **Workspace**: Plugin configuration and connection topology
    /// - **Connection Names**: Generated from `aligned_series_names()`
    /// - **Default Values**: Fallback settings for new or unconfigured plotters
    ///
    /// # Series Management
    /// - Automatically adjusts series count to match live connections
    /// - Preserves user-customized series names and settings
    /// - Assigns default colors using a predefined palette
    /// - Ensures minimum of one series for UI consistency
    ///
    /// # Default Configuration
    /// - **Visual**: Axes, legend, and grid enabled; dark theme
    /// - **Timebase**: 10 divisions, window from live plotter
    /// - **Series**: Auto-generated names, 1.0 scale, 0.0 offset
    /// - **Colors**: 8-color palette cycling for multiple series
    /// - **Export**: 1920x1080 PNG format
    ///
    /// # Use Cases
    /// - Initializing settings dialogs with current configuration
    /// - Preparing export operations with live data
    /// - Synchronizing UI state with plugin changes
    /// - Providing consistent defaults for new plotters
    pub(super) fn build_plotter_preview_state(&self, plugin_id: u64) -> PlotterPreviewState {
        let mut state = PlotterPreviewState::default();
        state.target = Some(plugin_id);
        let live_count = self
            .plotter_manager
            .plotters
            .get(&plugin_id)
            .and_then(|p| p.lock().ok().map(|p| p.input_count))
            .unwrap_or(0);
        let live_names = self.aligned_series_names(plugin_id, live_count);
        if let Some((
            show_axes,
            show_legend,
            show_grid,
            series_names,
            series_scales,
            series_offsets,
            colors,
            title,
            dark_theme,
            x_axis,
            y_axis,
            window_ms,
            timebase_divisions,
            high_quality,
            export_svg,
        )) = self
            .plotter_manager
            .plotter_preview_settings
            .get(&plugin_id)
            .cloned()
        {
            state.show_axes = show_axes;
            state.show_legend = show_legend;
            state.show_grid = show_grid;
            state.series_names = series_names;
            state.series_scales = series_scales;
            state.series_offsets = series_offsets;
            state.colors = colors;
            state.title = title;
            state.dark_theme = dark_theme;
            state.x_axis_name = x_axis;
            state.y_axis_name = y_axis;
            state.window_ms = window_ms;
            state.timebase_divisions = timebase_divisions.clamp(1, 200);
            state.high_quality = high_quality;
            state.export_svg = export_svg;
            if live_count > 0 {
                if state.series_names.len() < live_count {
                    for i in state.series_names.len()..live_count {
                        state.series_names.push(
                            live_names
                                .get(i)
                                .cloned()
                                .unwrap_or_else(|| format!("Series {}", i + 1)),
                        );
                        state.series_scales.push(1.0);
                        state.series_offsets.push(0.0);
                        state.colors.push(match i % 8 {
                            0 => egui::Color32::from_rgb(86, 156, 214),
                            1 => egui::Color32::from_rgb(220, 122, 95),
                            2 => egui::Color32::from_rgb(181, 206, 168),
                            3 => egui::Color32::from_rgb(220, 220, 170),
                            4 => egui::Color32::from_rgb(197, 134, 192),
                            5 => egui::Color32::from_rgb(78, 201, 176),
                            6 => egui::Color32::from_rgb(156, 220, 254),
                            _ => egui::Color32::from_rgb(255, 206, 84),
                        });
                    }
                } else if state.series_names.len() > live_count {
                    state.series_names.truncate(live_count);
                    state.series_scales.truncate(live_count);
                    state.series_offsets.truncate(live_count);
                    state.colors.truncate(live_count);
                }
                for (i, n) in live_names.into_iter().enumerate() {
                    if i < state.series_names.len() {
                        state.series_names[i] = n;
                    }
                }
            }
            if state.series_names.is_empty() {
                state.series_names.push("Series 1".to_string());
                state.series_scales.push(1.0);
                state.series_offsets.push(0.0);
                state.colors.push(egui::Color32::from_rgb(86, 156, 214));
            }
            return state;
        }
        if let Some(plotter) = self.plotter_manager.plotters.get(&plugin_id) {
            if let Ok(plotter) = plotter.lock() {
                state.show_axes = true;
                state.show_legend = true;
                state.show_grid = true;
                state.title = String::new();
                state.dark_theme = true;
                state.x_axis_name = self.state_sync.logic_time_label.clone();
                state.y_axis_name = "value".to_string();
                state.high_quality = false;
                state.series_names = (0..plotter.input_count)
                    .map(|i| {
                        live_names
                            .get(i)
                            .cloned()
                            .unwrap_or_else(|| format!("Series {}", i + 1))
                    })
                    .collect();
                state.series_scales = vec![1.0; plotter.input_count];
                state.series_offsets = vec![0.0; plotter.input_count];
                state.window_ms = plotter.window_ms;
                state.timebase_divisions = 10;
                state.refresh_hz = plotter.refresh_hz;
                state.colors = (0..plotter.input_count)
                    .map(|i| match i % 8 {
                        0 => egui::Color32::from_rgb(86, 156, 214),
                        1 => egui::Color32::from_rgb(220, 122, 95),
                        2 => egui::Color32::from_rgb(181, 206, 168),
                        3 => egui::Color32::from_rgb(220, 220, 170),
                        4 => egui::Color32::from_rgb(197, 134, 192),
                        5 => egui::Color32::from_rgb(78, 201, 176),
                        6 => egui::Color32::from_rgb(156, 220, 254),
                        _ => egui::Color32::from_rgb(255, 206, 84),
                    })
                    .collect();
            }
        }
        if let Some(plugin) = self
            .workspace_manager
            .workspace
            .plugins
            .iter()
            .find(|plugin| plugin.id == plugin_id)
        {
            state.priority = plugin.priority;
            state.refresh_hz = plugin
                .config
                .get("refresh_hz")
                .and_then(|v| v.as_f64())
                .unwrap_or(state.refresh_hz);
        }
        if state.series_names.is_empty() {
            state.series_names.push("Series 1".to_string());
            state.series_scales.push(1.0);
            state.series_offsets.push(0.0);
            state.colors.push(egui::Color32::from_rgb(86, 156, 214));
        }
        state
    }

    /// Applies a plotter preview state to persistent storage and plugin configuration.
    ///
    /// This function takes a complete plotter preview state and persists it to the
    /// appropriate storage locations, updating both the plotter manager's settings
    /// and the plugin's workspace configuration. It ensures that user customizations
    /// are preserved across application sessions.
    ///
    /// # Parameters
    /// - `plugin_id`: The ID of the plugin to apply settings to
    /// - `state`: The preview state containing all settings to apply
    ///
    /// # Storage Updates
    /// 1. **Plotter Manager**: Stores visual and series settings in preview settings map
    /// 2. **Plugin Config**: Updates plugin priority and refresh rate in workspace
    /// 3. **Workspace Persistence**: Marks workspace as dirty for automatic saving
    /// 4. **Logic Engine**: Sends updated workspace to background processing
    ///
    /// # Settings Applied
    /// - **Visual Settings**: Axes, legend, grid visibility, theme, titles
    /// - **Series Configuration**: Names, scales, offsets, colors
    /// - **Timebase Settings**: Window duration, division count
    /// - **Export Options**: Quality settings, format preferences
    /// - **Plugin Parameters**: Priority level, refresh rate
    ///
    /// # Data Validation
    /// - Clamps timebase divisions to valid range (1-200)
    /// - Ensures refresh rate is at least 1.0 Hz
    /// - Validates all numeric parameters are within reasonable bounds
    ///
    /// # Side Effects
    /// - Triggers workspace persistence mechanism
    /// - Updates live plugin configuration in logic engine
    /// - May affect plugin execution priority and timing
    /// - Influences plotter rendering performance and quality
    ///
    /// # Use Cases
    /// - Saving user customizations from settings dialogs
    /// - Applying export configurations before image capture
    /// - Persisting changes made through interactive controls
    /// - Batch updating multiple plotter configurations
    ///
    /// # Implementation Notes
    /// - Uses tuple storage format for efficient serialization
    /// - Handles missing plugins gracefully without errors
    /// - Maintains backward compatibility with existing settings
    /// - Ensures atomic updates to prevent inconsistent state
    pub(super) fn apply_plotter_preview_state(&mut self, plugin_id: u64, state: &PlotterPreviewState) {
        self.plotter_manager.plotter_preview_settings.insert(
            plugin_id,
            (
                state.show_axes,
                state.show_legend,
                state.show_grid,
                state.series_names.clone(),
                state.series_scales.clone(),
                state.series_offsets.clone(),
                state.colors.clone(),
                state.title.clone(),
                state.dark_theme,
                state.x_axis_name.clone(),
                state.y_axis_name.clone(),
                state.window_ms,
                state.timebase_divisions.clamp(1, 200),
                state.high_quality,
                state.export_svg,
            ),
        );
        if let Some(plugin) = self
            .workspace_manager
            .workspace
            .plugins
            .iter_mut()
            .find(|plugin| plugin.id == plugin_id)
        {
            plugin.priority = state.priority;
            if let Some(config) = plugin.config.as_object_mut() {
                config.insert(
                    "refresh_hz".to_string(),
                    Value::from(state.refresh_hz.max(1.0)),
                );
            }
            self.mark_workspace_dirty();
            let _ = self.state_sync.logic_tx.send(LogicMessage::UpdateWorkspace(
                self.workspace_manager.workspace.clone(),
            ));
        }
    }

    /// Constructs series transform objects from scale and offset arrays.
    ///
    /// This utility function converts separate arrays of scaling factors and offset
    /// values into a vector of `SeriesTransform` objects that can be used by the
    /// plotter rendering system. It handles array length mismatches gracefully.
    ///
    /// # Parameters
    /// - `scales`: Array of scaling factors for each series
    /// - `offsets`: Array of offset values for each series
    /// - `count`: Number of transform objects to create
    ///
    /// # Returns
    /// A `Vec<SeriesTransform>` containing transform objects for plotter rendering
    ///
    /// # Transform Construction
    /// For each series index from 0 to `count`:
    /// - Uses the corresponding scale value, or defaults to 1.0 if array is too short
    /// - Uses the corresponding offset value, or defaults to 0.0 if array is too short
    /// - Creates a `SeriesTransform` object with these values
    ///
    /// # Default Behavior
    /// - **Missing Scale**: Defaults to 1.0 (no scaling)
    /// - **Missing Offset**: Defaults to 0.0 (no offset)
    /// - **Empty Arrays**: Creates transforms with default values
    ///
    /// # Use Cases
    /// - Converting UI control values to plotter-compatible format
    /// - Preparing transform data for plot rendering
    /// - Handling dynamic series count changes
    /// - Providing consistent transform objects regardless of input array lengths
    ///
    /// # Mathematical Application
    /// Each transform applies the formula: `output = (input * scale) + offset`
    /// - Scale adjusts the amplitude/magnitude of the signal
    /// - Offset shifts the signal vertically (DC bias adjustment)
    ///
    /// # Implementation Details
    /// - Uses safe array indexing with fallback defaults
    /// - Creates exactly `count` transform objects regardless of input lengths
    /// - Maintains consistent behavior for edge cases
    /// - Optimized for frequent calls during UI updates
    pub(super) fn build_series_transforms(
        scales: &[f64],
        offsets: &[f64],
        count: usize,
    ) -> Vec<crate::plotter::SeriesTransform> {
        (0..count)
            .map(|i| crate::plotter::SeriesTransform {
                scale: *scales.get(i).unwrap_or(&1.0),
                offset: *offsets.get(i).unwrap_or(&0.0),
            })
            .collect()
    }
}
